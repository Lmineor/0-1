# 共识算法
## 问题和挑战
共识需要解决的两个基本问题：
1. 如何提出一个待共识的提案？如通过令牌传递、随机选取、权重比较、求解难题等；
2. 如果让多个节点对该提案达成共识（同意或决绝），如投票、规则验证等。

理论情况下：各个节点都能以十分“理想”的性能运行（瞬间相应、超高吞吐），节点之间通信瞬时送达（如量子纠缠），则可通过简单的投票和应答来实现共识。
但往往会有如下情况发生：通信中断、节点故障、节点被入侵故意伪造消息等来破坏共识过程。

会出现两种错误：
- 非拜占庭错误（Non-Byzantine Fault）或故障错误（Crash Fault）：出现故障（Crash或Fail-Stop）但不会伪造信息的情况；
- 拜占庭错误（Byzantine Fault）：恶意伪造信息。
显然，后者场景中因为存在“捣乱者”更难达成共识。


此外，任何处理都需要成本，共识也是如此。当存在一定信任前提（如接入节点都经过验证、节点性能稳定、安全保障很高）时，达成共识相对容易，共识性能也较高；反之在不可信的场景下，达成共识很难，需要付出较大的成本，而且性能往往较差（如工作量证明算法）。

## 常见算法
共识算法可以分为Crash Fault Tolerance（CFT）和Byzantine Fault Tolerance（BFT）两类。

- CFT：Paxos、Raft及其变种。性能较好，处理较快，容忍不超过一般的故障节点。
- BFT：PBFT（Practical Byzantine Fault Tolerance）为代表的确定性系列算法、Pow为代表的概率算法等。此类算法容错性能较差，不能超过1/3的故障节点。
	- 确定性算法一旦达成共识就不可逆转，即共识是最终结果；
	- 概率算法的共识是临时的，随着时间推移或某种强化，共识结果被推翻的概率越来越小，最终成为事实上的结果。

此外，XFT（Cross Fault Tolerance，2015 年）等最近提出的改进算法可以提供类似 CFT 的处理响应速度，并能在大多数节点正常工作时提供 BFT 保障。

Algorand 算法（2017 年）基于 PBFT 进行改进，通过引入可验证随机函数解决了提案选择的问题，理论上可以在容忍拜占庭错误的前提下实现更好的性能（1000+ TPS）。

_注：实践中，对客户端来说要拿到共识结果需要自行验证，典型地，可访问足够多个服务节点来比对结果，确保获取结果的准确性。_

---

# FLP不可能原理

## 定义
在网络可靠、但允许节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性共识算法。
该原理告诉我们：不要浪费时间去试图为异步分布式系统设计面向任意场景的共识算法。


---
# CAP原理
## 定义：
分布式系统无法同时确保一致性（Consistency）、可用性（Availability）和分区容忍性（Partition），设计中往往需要弱化对某个特性的需求。
一致性、可用性和分区容忍性的具体含义如下：
- 一致性（Consistency）：任何事务都应该是原子的，所有副本上的状态都是事务成功提交后的结果，并保持强一致性；
- 可用性（Availability）：系统（非失败节点）能在有限时间内完成对操作请求的应答；
- 分区容忍性（Partition）：系统中的网络可能发生分区故障（成为多个子网，甚至出现节点上线和下线），即节点之间的通信无法保障。而网络故障不应该影响到系统正常服务。

CAP原理认为：分布式系统最多只能保证三项特性中的两项特性。

## 应用场景：
既然CAP三种特性bu'ken