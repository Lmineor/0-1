# 共识算法
## 问题和挑战
共识需要解决的两个基本问题：
1. 如何提出一个待共识的提案？如通过令牌传递、随机选取、权重比较、求解难题等；
2. 如果让多个节点对该提案达成共识（同意或决绝），如投票、规则验证等。

理论情况下：各个节点都能以十分“理想”的性能运行（瞬间相应、超高吞吐），节点之间通信瞬时送达（如量子纠缠），则可通过简单的投票和应答来实现共识。
但往往会有如下情况发生：通信中断、节点故障、节点被入侵故意伪造消息等来破坏共识过程。

会出现两种错误：
- 非拜占庭错误（Non-Byzantine Fault）或故障错误（Crash Fault）：出现故障（Crash或Fail-Stop）但不会伪造信息的情况；
- 拜占庭错误（Byzantine Fault）：恶意伪造信息。
显然，后者场景中因为存在“捣乱者”更难达成共识。


此外，任何处理都需要成本，共识也是如此。当存在一定信任前提（如接入节点都经过验证、节点性能稳定、安全保障很高）时，达成共识相对容易，共识性能也较高；反之在不可信的场景下，达成共识很难，需要付出较大的成本，而且性能往往较差（如工作量证明算法）。

## 常见算法
共识算法可以分为Crash Fault Tolerance（CFT）和Byzantine Fault Tolerance（BFT）两类。

- CFT：Paxos、Raft及其变种。性能较好，处理较快，容忍不超过一般的故障节点。
- BFT：PBFT（Practical Byzantine Fault Tolerance）为代表的确定性系列算法、Pow为代表的概率算法等。此类算法容错性能较差，不能超过1/3的故障节点。
	- 确定性算法一旦达成共识就不可逆转，即共识是最终结果；
	- 概率算法的共识是临时的，随着时间推移或某种强化，共识结果被推翻的概率越来越小，最终成为事实上的结果。

此外，XFT（Cross Fault Tolerance，2015 年）等最近提出的改进算法可以提供类似 CFT 的处理响应速度，并能在大多数节点正常工作时提供 BFT 保障。

Algorand 算法（2017 年）基于 PBFT 进行改进，通过引入可验证随机函数解决了提案选择的问题，理论上可以在容忍拜占庭错误的前提下实现更好的性能（1000+ TPS）。

_注：实践中，对客户端来说要拿到共识结果需要自行验证，典型地，可访问足够多个服务节点来比对结果，确保获取结果的准确性。_

---

# FLP不可能原理

## 定义
在网络可靠、但允许节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性共识算法。
该原理告诉我们：不要浪费时间去试图为异步分布式系统设计面向任意场景的共识算法。


---
# CAP原理
## 定义：
分布式系统无法同时确保一致性（Consistency）、可用性（Availability）和分区容忍性（Partition），设计中往往需要弱化对某个特性的需求。
一致性、可用性和分区容忍性的具体含义如下：
- 一致性（Consistency）：任何事务都应该是原子的，所有副本上的状态都是事务成功提交后的结果，并保持强一致性；
- 可用性（Availability）：系统（非失败节点）能在有限时间内完成对操作请求的应答；
- 分区容忍性（Partition）：系统中的网络可能发生分区故障（成为多个子网，甚至出现节点上线和下线），即节点之间的通信无法保障。而网络故障不应该影响到系统正常服务。

CAP原理认为：分布式系统最多只能保证三项特性中的两项特性。

## 应用场景：
既然CAP三种特性不可同时得到保障，则设计系统时候必然要弱化对某个特性的支持。

### 弱化一致性
对结果一致性不敏感的应用，可以允许新版本上线后过一段时间才最终更新成功，期间不保证一致性。

### 弱化可用性
对结果一致性很敏感的应用，当系统故障时可以决绝服务。MongoDB、Redis、MapReduce等为此设计。

Paxos、Raft等共识算法，主要处理这种情况。在Paxos类算法中，可能存在着无法提供可用结果的清醒，同时允许少数节点离线。

### 弱化分区容忍性
现实中，网络分区出现概率较小，但很难完全避免。
两阶段的提交算法，某些关系型数据库以及ZooKeeper主要考虑了这种设计。
实践中，网络可以通过双通道等机制增强可靠性，实现高稳定的网络通信。

---
# ACID原则与多阶段提交
## ACID原则
原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
ACID原则描述了分布式数据库需要满足的一致性需求，同时允许付出可用性的代价。

- A：每次事务是原子的，事务包含的所有操作要么全部成功，要么全部不执行。一旦有操作失败，则需要回退到执行事务之前。
- C：数据库的状态在事务执行前后的状态是一致的和完整的，无中间状态。即只能处于成功事务提交后的状态。
- I：各种事务可以并发执行，但彼此之间互相不影响。按照标准SQL规范，从弱到强可以分为未授权读、授权读取、可重复度读取和串行化四种隔离级别。
- D：状态的改变是持久的，不会失效。一旦某个事务提交，则它造成的状态变更就是永久的。

## 两阶段（Two-Phase Commit， 2PC）提交
预提交和正式提交两个阶段，规避冲突的风险：
- 预提交：协调者（Coordinator）发起某个事务的申请，各参与执行者（Participant）需要尝试进行提交并反馈是否完成
- 正式提交：协调者如果得到所有执行者的成功答复，则发出正式提交请求。如果成功完成，则算法执行成功。

两阶段提交算法因为简单容易实现的优点，在关系型数据库等系统中被广泛应用。
当然也有缺点：整个过程需要同步阻塞导致性能一般较差；同时存在单点问题，较坏情况下可能一直无法完成提交；另外可能产生数据不一致的情况（例如协调者和执行者在第二个节点出现故障）。
## 三阶段提交
- 尝试预提交：协调者询问执行者能否进行某个事务的提交。执行者需要回复，但无需执行提交。这就避免出现部分执行者被无效阻塞住的情况；
- 预提交“协调者检查受到的答复，如果全部为真，发起提交事务的请求。各参与者尝试提交并反馈是否完成；
- 正式提交：协调者如果得到所有执行者的成功答复，则发出正式提交请求。如果成功完成，则算法执行成功。

无论是两阶段还是三阶段提交，都只是一定程度上缓解了提交冲突的问题，并无法一定保证系统的一致性。收个有效的算法是Paxos算法。

---

# Paxos和Raft算法
## Paxos
## Raft
参见：[raft共识算法](../raft共识算法.md)
两个主要阶段：
- leader Selection
- Sync Log Entry

领导者会定期向所有跟随者发送心跳消息，跟随者如果发现心跳超时未收到，则可以认为领导者已经down掉，此时会变为candidate之后尝试发起新的选举过程。


---
# 可靠性指标
## 几个9指标
参考[可靠性指标]([可靠性指标 - 区块链技术指南 (gitbook.io)](https://yeasy.gitbook.io/blockchain_guide/04_distributed_system/availability))

## 两个核心时间
- MTBF：Mean Time Between Failures，平均故障时间，即系统可以无故障运行的时间。
- MTTR：Mean Time To Repair，平均修复时间，即故障发生后，系统可以恢复到正常运行的预期时间。
MTBF衡量了系统发生故障的pin