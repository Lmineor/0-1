# 共识算法
## 问题和挑战
共识需要解决的两个基本问题：
1. 如何提出一个待共识的提案？如通过令牌传递、随机选取、权重比较、求解难题等；
2. 如果让多个节点对该提案达成共识（同意或决绝），如投票、规则验证等。

理论情况下：各个节点都能以十分“理想”的性能运行（瞬间相应、超高吞吐），节点之间通信瞬时送达（如量子纠缠），则可通过简单的投票和应答来实现共识。
但往往会有如下情况发生：通信中断、节点故障、节点被入侵故意伪造消息等来破坏共识过程。

会出现两种错误：
- 非拜占庭错误（Non-Byzantine Fault）或故障错误（Crash Fault）：出现故障（Crash或Fail-Stop）但不会伪造信息的情况；
- 拜占庭错误（Byzantine Fault）：恶意伪造信息。
显然，后者场景中因为存在“捣乱者”更难达成共识。


此外，任何处理都需要成本，共识也是如此。当存在一定信任前提（如接入节点都经过验证、节点性能稳定、安全保障很高）时，达成共识相对容易，共识性能也较高；反之在不可信的场景下，达成共识很难，需要付出较大的成本，而且性能往往较差（如工作量证明算法）。

## 常见算法
共识算法可以分为Crash Fault Tolerance（CFT）和Byzantine Fault Tolerance（BFT）两类。

- CFT：Paxos、Raft及其变种。性能较好，处理较快，容忍不超过一般的故障节点。
- BFT：PBFT（Practical Byzantine Fault Tolerance）为代表的确定性系列算法、Pow为代表的概率算法等。
	- 确定性算法一旦达成共识就不可逆转，即共识shi